import sys
import pefile
from feature_sender import *
from model import *

def features(file_path):
    # Load the PE file
    pe = pefile.PE(file_path)

    # Extract the list of imported DLLs
    imported_dlls = []
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        imported_dlls.append(entry.dll.decode().lower())

    # Extract the list of imported DLLs and check if they are in the list of known DLLs
    dlls = dll_features_list()
    dlls_features = [1 if dll in imported_dlls else 0 for dll in dlls]

    # Extract the list of API functions called
    api_functions = []
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        for imp in entry.imports:
            api_functions.append(imp.name.decode().lower())
    api_list = api_features_list()
    api_features = [1 if api in api_functions else 0 for api in api_list]

    pe_header_features = pe_header_features_list()
    pe_header_values = [
        pe.DOS_HEADER.e_magic,
        pe.DOS_HEADER.e_cblp,
        pe.DOS_HEADER.e_cp,
        pe.DOS_HEADER.e_crlc,
        pe.DOS_HEADER.e_cparhdr,
        pe.DOS_HEADER.e_minalloc,
        pe.DOS_HEADER.e_maxalloc,
        pe.DOS_HEADER.e_ss,
        pe.DOS_HEADER.e_sp,
        pe.DOS_HEADER.e_csum,
        pe.DOS_HEADER.e_ip,
        pe.DOS_HEADER.e_cs,
        pe.DOS_HEADER.e_lfarlc,
        pe.DOS_HEADER.e_ovno,
        pe.DOS_HEADER.e_oemid,
        pe.DOS_HEADER.e_oeminfo,
        pe.DOS_HEADER.e_lfanew,
        pe.FILE_HEADER.Machine,
        pe.FILE_HEADER.NumberOfSections,
        pe.FILE_HEADER.TimeDateStamp,
        pe.FILE_HEADER.PointerToSymbolTable,
        pe.FILE_HEADER.NumberOfSymbols,
        pe.FILE_HEADER.SizeOfOptionalHeader,
        pe.FILE_HEADER.Characteristics,
        pe.OPTIONAL_HEADER.Magic,
        pe.OPTIONAL_HEADER.MajorLinkerVersion,
        pe.OPTIONAL_HEADER.MinorLinkerVersion,
        pe.OPTIONAL_HEADER.SizeOfCode,
        pe.OPTIONAL_HEADER.SizeOfInitializedData,
        pe.OPTIONAL_HEADER.SizeOfUninitializedData,
        pe.OPTIONAL_HEADER.AddressOfEntryPoint,
        pe.OPTIONAL_HEADER.BaseOfCode,
        pe.OPTIONAL_HEADER.ImageBase,
        pe.OPTIONAL_HEADER.SectionAlignment,
        pe.OPTIONAL_HEADER.FileAlignment,
        pe.OPTIONAL_HEADER.MajorOperatingSystemVersion,
        pe.OPTIONAL_HEADER.MinorOperatingSystemVersion,
        pe.OPTIONAL_HEADER.MajorImageVersion,
        pe.OPTIONAL_HEADER.MinorImageVersion,
        pe.OPTIONAL_HEADER.MajorSubsystemVersion,
        pe.OPTIONAL_HEADER.MinorSubsystemVersion,
        pe.OPTIONAL_HEADER.Reserved1,
        pe.OPTIONAL_HEADER.SizeOfImage,
        pe.OPTIONAL_HEADER.SizeOfHeaders,
        pe.OPTIONAL_HEADER.CheckSum,
        pe.OPTIONAL_HEADER.Subsystem,
        pe.OPTIONAL_HEADER.DllCharacteristics,
        pe.OPTIONAL_HEADER.SizeOfStackReserve,
        pe.OPTIONAL_HEADER.SizeOfHeapReserve,
        pe.OPTIONAL_HEADER.SizeOfHeapCommit,
        pe.OPTIONAL_HEADER.LoaderFlags,
        pe.OPTIONAL_HEADER.NumberOfRvaAndSizes
    ]


    # Define the section names in the specified order
    section_names = ["text", "data", "rdata", "bss", "idata", "edata", "rsrc", "reloc", "tls", "pdata"]

    # Define the attributes to extract for each section
    attributes_to_extract = ["Misc_VirtualSize", "VirtualAddress", "SizeOfRawData", "PointerToRawData",
                            "PointerToRelocations", "PointerToLinenumbers", "NumberOfRelocations",
                            "NumberOfLinenumbers", "Characteristics"]

    # Create a list to store the values
    section_values = []

    # Iterate through the section names and extract attributes
    for section_name in section_names:
        found_section = None
        for section in pe.sections:
            if section_name in section.Name.decode('utf-8').strip('\x00').lower():
                found_section = section
                break

        if found_section:
            # If the section is found, extract the attributes
            section_attributes = [getattr(found_section, attr) for attr in attributes_to_extract]
        else:
            # If the section is not found, assign 0 to all attributes
            section_attributes = [0] * len(attributes_to_extract)

        section_values.extend(section_attributes)

    return dlls_features, api_features, pe_header_values, section_values

if __name__ == "__main__":
    file_path =  sys.argv[1] # Replace with the path to your PE file
    dlls_features, api_features, pe_header_values, section_values = features(file_path)
    predict_malware(dlls_features, api_features, pe_header_values, section_values)
